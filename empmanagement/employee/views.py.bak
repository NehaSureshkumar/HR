from django.shortcuts import redirect, render, get_object_or_404
from .forms import *
from employee.models import (
    Employee, Attendance, Notice, workAssignments, 
    Document, UserProfile, AuditLog, JobOpening,
    designations_opt, DOCUMENT_TYPES, PerformanceReview, Goal, LeaveRequest,
    TrainingProgram, TrainingEnrollment, Payroll, Project, EmployeeInformation, IDCard, WiFiAccess, ParkingDetails, InsuranceDetails, ProfileUpdateRequest,
    TrainingTag, TrainingBlog, TrainingDocument, Asset, AssetCategory, AssetAssignment,
    BankDetail, InsurancePolicy, TaxDetail, PersonalDetail, Shift, EmployeeShift,
    Leave, LeaveType, LeaveBalance
)
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test
from django.utils import timezone
from functools import wraps
from django.http import JsonResponse
from django.core.paginator import Paginator
from django.db import models
from django.db.models import Sum, Count, Avg, Q
from datetime import datetime, timedelta, time
import uuid
from django.contrib.auth.models import User
from django.contrib.admin.views.decorators import staff_member_required
import csv
from django.http import HttpResponse
from django import forms
from rest_framework import viewsets, serializers
from django.core.mail import send_mail
from django.conf import settings
import random
import string
import logging
from django.views.decorators.http import require_http_methods
from .utils import get_auth_url, get_access_token_from_code, test_email_sending, initiate_auth as utils_initiate_auth, auth_callback as utils_auth_callback
from .decorators import role_required
import json
from django.db import IntegrityError
from django.db.models.functions import TruncDate, TruncMonth

def staff_required(view_func):
    decorated_view_func = user_passes_test(lambda u: u.is_staff, login_url='/')(view_func)
    return decorated_view_func

def is_hr_or_admin(user):
    return user.is_superuser or user.groups.filter(name='HR').exists()

# Create your views here.
@login_required(login_url='/ems/accounts/login/')
def dashboard(request):
    try:
        user_profile = UserProfile.objects.get(user=request.user)
        
        # Redirect admins/HR to their dashboard
        if user_profile.role in ['ADMIN', 'HR']:
            return redirect('admin_dashboard')
        
        # Get employee info for the logged-in user only
        employee = Employee.objects.get(eID=request.user.username)
        
        # Get attendance count for current month
        current_month = timezone.now().month
        attendance_count = Attendance.objects.filter(
            eId=employee.eID,
            date__month=current_month,
            status='PRESENT'
        ).count()
        
        # Get leave balance (assuming 20 days annual leave)
        leave_requests = LeaveRequest.objects.filter(
            eId=employee.eID,
            status='APPROVED',
            start_date__year=timezone.now().year
        )
        leave_taken = sum((lr.end_date - lr.start_date).days + 1 for lr in leave_requests)
        leave_balance = 20 - leave_taken
        
        # Get pending tasks count
        task_count = workAssignments.objects.filter(
            taskerId=employee,
            dueDate__gte=timezone.now()
        ).count()
        
        # Get enrolled training programs count
        training_count = TrainingEnrollment.objects.filter(
            employee=employee,
            status='ENROLLED'
        ).count()
        
        # Get recent tasks
        recent_tasks = workAssignments.objects.filter(
            taskerId=employee
        ).order_by('-assignDate')[:5]
        
        # Get recent notices
        recent_notices = Notice.objects.all().order_by('-publishDate')[:5]
        
        # Get assigned projects count
        assigned_projects_count = employee.projects.count()
        
        context = {
            'employee': employee,
            'attendance_count': attendance_count,
            'leave_balance': leave_balance,
            'task_count': task_count,
            'training_count': training_count,
            'recent_tasks': recent_tasks,
            'recent_notices': recent_notices,
            'assigned_projects_count': assigned_projects_count,
            'user_profile': user_profile
        }
        
        return render(request, 'employee/index.html', context)
        
    except UserProfile.DoesNotExist:
        messages.error(request, "User profile not found.")
        return redirect('login')
    except Employee.DoesNotExist:
        messages.error(request, "Employee record not found.")
        return redirect('login')
    
@login_required(login_url='/')
def notice(request):
    notices  = Notice.objects.all()
    return render(request,"employee/notice.html",{"notices":notices})

@login_required(login_url='/')
def noticedetail(request,id):
    noticedetail = Notice.objects.get(Id=id)
    return render(request,"employee/noticedetail.html",{"noticedetail":noticedetail})

@login_required(login_url='/')
def assignWork(request):
    context={}
    initialData = {
        "assignerId" : request.user.username,
    }
    flag = ""
    form = workform(request.POST or None, initial=initialData)
    if form.is_valid():
        currentTaskerId = request.POST["taskerId"]
        currentUserId = request.user.username
        if currentTaskerId == currentUserId:
            flag="Invalid ID Selected..."
        else:
            # Generate a unique ID for the work assignment
            work_instance = form.save(commit=False)
            work_instance.Id = f"WRK-{uuid.uuid4().hex[:8].upper()}"
            work_instance.save()
            flag = "Work Assigned Successfully!!"

    context['form']=form
    context['flag'] = flag
    return render(request,"employee/workassign.html",context)

@login_required(login_url='/')
def mywork(request):
    try:
        # Get work assignments for the current user
        work_assignments = workAssignments.objects.filter(taskerId__eID=request.user.username)
        # Get employee object
        employee = get_object_or_404(Employee, eID=request.user.username)
        # Get assigned projects
        assigned_projects = employee.projects.all()
        # Add current date for template comparison
        context = {
            'work': work_assignments,
            'now': timezone.now().date(),
            'employee': employee,
            'assigned_projects': assigned_projects
        }
        return render(request, "employee/mywork.html", context)
    except Exception as e:
        messages.error(request, f"Error loading work assignments: {str(e)}")
        return redirect('dashboard')

@login_required(login_url='/')
def workdetails(request,wid):
    workdetails = workAssignments.objects.get(Id=wid)
    return render(request,"employee/workdetails.html",{"workdetails":workdetails})

@login_required(login_url='/')
def assignedworklist(request):
    try:
        # Check if user is admin/HR
        user_profile = UserProfile.objects.get(user=request.user)
        
        # Get work assignments
        works = workAssignments.objects.filter(assignerId=request.user.username).all()
        
        # Only check profile completion for regular employees
        if user_profile.role not in ['ADMIN', 'HR']:
            employee = Employee.objects.get(eID=request.user.username)
            documents = Document.objects.filter(employee=employee)
            if user_profile.profile_completion < 100 or documents.count() < 3:
                return redirect('employee_onboarding')
        
        return render(request, "employee/assignedworklist.html", {
            "works": works,
            "now": timezone.now().date()
        })
    except Exception as e:
        messages.error(request, f"Error loading work assignments: {str(e)}")
        return redirect('dashboard')

@login_required(login_url='/')
def deletework(request, wid):
    obj = get_object_or_404(workAssignments, Id=wid)
    obj.delete()
    return redirect('assignedworklist')

@login_required(login_url='/')
def updatework(request,wid):
    work = workAssignments.objects.get(Id=wid)
    form = workform(request.POST or None, instance=work)
    flag = ""
    if form.is_valid():
        currentTaskerId = request.POST["taskerId"]
        currentUserId = request.user.username
        if currentTaskerId == currentUserId:
            flag="Invalid ID Selected..."
        else:
            flag = "Work Updated Successfully!!"
            form.save()
    return render(request,"employee/updatework.html", {'currentWork': work, "filledForm": form, "flag":flag})

@login_required
def profile(request):
    try:
        employee = Employee.objects.get(eID=request.user.username)
        user_profile = get_object_or_404(UserProfile, user=request.user)
        bank_details = BankDetail.objects.filter(employee=employee).first()
        
        # Initialize forms
        employee_info_form = EmployeeInformationForm(instance=getattr(employee, 'employeeinformation', None))
        id_card_form = IDCardForm(instance=getattr(employee, 'idcard', None))
        wifi_access_form = WiFiAccessForm(instance=getattr(employee, 'wifiaccess', None))
        parking_form = ParkingDetailsForm(instance=getattr(employee, 'parkingdetails', None))
        insurance_form = InsuranceDetailsForm(instance=getattr(employee, 'insurancedetails', None))
        
        if request.method == 'POST':
            form_type = request.POST.get('form_type')
            
            if form_type == 'personal':
                # Update personal details
                employee.firstName = request.POST.get('firstName')
                employee.lastName = request.POST.get('lastName')
                employee.dOB = request.POST.get('dOB')
                employee.addharNo = request.POST.get('addharNo')
                employee.save()
                messages.success(request, 'Personal details updated successfully!')
                
            elif form_type == 'contact':
                # Update contact info
                employee.email = request.POST.get('email')
                employee.personal_email = request.POST.get('personal_email')
                employee.phoneNo = request.POST.get('phoneNo')
                employee.save()
                messages.success(request, 'Contact information updated successfully!')
                
            elif form_type == 'employment':
                form = EmployeeInformationForm(request.POST, instance=getattr(employee, 'employeeinformation', None))
                if form.is_valid():
                    info = form.save(commit=False)
                    info.employee = employee
                    info.save()
                    messages.success(request, 'Employment details updated successfully!')
                else:
                    messages.error(request, 'Please correct the errors below.')
                    employee_info_form = form
                
            elif form_type == 'bank':
                # Update or create bank details
                if bank_details:
                    bank_details.bank_name = request.POST.get('bank_name')
                    bank_details.account_number = request.POST.get('account_number')
                    bank_details.ifsc = request.POST.get('ifsc')
                    bank_details.branch = request.POST.get('branch')
                    bank_details.save()
                else:
                    bank_details = BankDetail.objects.create(
                        employee=employee,
                        bank_name=request.POST.get('bank_name'),
                        account_number=request.POST.get('account_number'),
                        ifsc=request.POST.get('ifsc'),
                        branch=request.POST.get('branch')
                    )
                messages.success(request, 'Bank details updated successfully!')
                
            elif form_type == 'emergency':
                # Update emergency contact
                user_profile.emergency_contact_name = request.POST.get('emergency_contact_name')
                user_profile.emergency_contact_phone = request.POST.get('emergency_contact_phone')
                user_profile.save()
                messages.success(request, 'Emergency contact updated successfully!')
                
            elif form_type == 'id_card':
                form = IDCardForm(request.POST, instance=getattr(employee, 'idcard', None))
                if form.is_valid():
                    card = form.save(commit=False)
                    card.employee = employee
                    card.save()
                    messages.success(request, 'ID Card details updated successfully!')
                else:
                    messages.error(request, 'Please correct the errors below.')
                    id_card_form = form
                
            elif form_type == 'wifi_access':
                form = WiFiAccessForm(request.POST, instance=getattr(employee, 'wifiaccess', None))
                if form.is_valid():
                    wifi = form.save(commit=False)
                    wifi.employee = employee
                    wifi.save()
                    messages.success(request, 'WiFi access details updated successfully!')
                else:
                    messages.error(request, 'Please correct the errors below.')
                    wifi_access_form = form
                
            elif form_type == 'parking':
                form = ParkingDetailsForm(request.POST, instance=getattr(employee, 'parkingdetails', None))
                if form.is_valid():
                    parking = form.save(commit=False)
                    parking.employee = employee
                    parking.save()
                    messages.success(request, 'Parking details updated successfully!')
                else:
                    messages.error(request, 'Please correct the errors below.')
                    parking_form = form
                
            elif form_type == 'insurance':
                form = InsuranceDetailsForm(request.POST, instance=getattr(employee, 'insurancedetails', None))
                if form.is_valid():
                    insurance = form.save(commit=False)
                    insurance.employee = employee
                    insurance.save()
                    messages.success(request, 'Insurance details updated successfully!')
                else:
                    messages.error(request, 'Please correct the errors below.')
                    insurance_form = form
        
        return render(request, 'employee/profile.html', {
            'employee': employee,
            'profile': user_profile,
            'bank_details': bank_details or BankDetail(),
            'employee_info_form': employee_info_form,
            'id_card_form': id_card_form,
            'wifi_access_form': wifi_access_form,
            'parking_form': parking_form,
            'insurance_form': insurance_form,
        })
        
    except Employee.DoesNotExist:
        messages.error(request, "Employee profile not found.")
        return redirect('dashboard')

@login_required
def my_documents(request):
    try:
        # Use eID instead of user field
        employee = Employee.objects.get(eID=request.user.username)
        documents = employee.documents.all().order_by('-uploaded_at')
        
        # Get document verification statuses
        info_statuses = {
            'id_verified': documents.filter(document_type='ID_PROOF', is_verified=True).exists(),
            'address_verified': documents.filter(document_type='ADDRESS_PROOF', is_verified=True).exists(),
            'education_verified': documents.filter(document_type='EDUCATION', is_verified=True).exists(),
            'experience_verified': documents.filter(document_type='EXPERIENCE', is_verified=True).exists(),
        }
        
        return render(request, 'employee/my_documents.html', {
            'documents': documents,
            'info_statuses': info_statuses,
        })
    except Employee.DoesNotExist:
        messages.error(request, "Employee profile not found.")
        return redirect('dashboard')

@login_required
def upload_document(request):
    try:
        # Use eID instead of user field
        employee = Employee.objects.get(eID=request.user.username)
        
        if request.method == 'POST':
            document_type = request.POST.get('document_type')
            description = request.POST.get('description')
            file = request.FILES.get('document')
            
            if document_type and file:
                document = Document.objects.create(
                    employee=employee,
                    document_type=document_type,
                    description=description,
                    file=file
                )
                messages.success(request, 'Document uploaded successfully!')
                return redirect('my_documents')
            else:
                messages.error(request, 'Please provide all required information.')
        
        return render(request, 'employee/upload_document.html')
    except Employee.DoesNotExist:
        messages.error(request, "Employee profile not found.")
        return redirect('dashboard')

@login_required
def update_document(request, doc_id):
    try:
        # Use eID instead of user field
        employee = Employee.objects.get(eID=request.user.username)
        document = get_object_or_404(Document, id=doc_id, employee=employee)
        
        if document.is_verified:
            messages.error(request, "Cannot update a verified document.")
            return redirect('my_documents')
        
        if request.method == 'POST':
            description = request.POST.get('description')
            file = request.FILES.get('document')
            
            if file:
                document.file = file
            if description:
                document.description = description
            document.save()
            
            messages.success(request, 'Document updated successfully!')
            return redirect('my_documents')
        
        return render(request, 'employee/update_document.html', {'document': document})
    except Employee.DoesNotExist:
        messages.error(request, "Employee profile not found.")
        return redirect('dashboard')

@login_required(login_url='/')
@role_required(['ADMIN', 'HR'])
def document_verification(request):
    status_filter = request.GET.get('status', 'all')
    
    # Get all employees
    employees = Employee.objects.all().order_by('-joinDate')
    
    # Add validation status to each employee
    for employee in employees:
        # Document status
        documents = Document.objects.filter(employee=employee)
        doc_count = documents.count()
        
        # Form status
        pending_updates = ProfileUpdateRequest.objects.filter(
            employee=employee,
            status='PENDING'
        ).exists()
        
        has_employee_info = hasattr(employee, 'employeeinformation')
        has_id_card = hasattr(employee, 'idcard')
        has_wifi_access = hasattr(employee, 'wifiaccess')
        has_parking = hasattr(employee, 'parkingdetails')
        has_insurance = hasattr(employee, 'insurancedetails')
        
        # Determine form validation status
        if pending_updates:
            employee.validation_status = 'PENDING'
        elif all([has_employee_info, has_id_card, has_wifi_access, has_parking, has_insurance]):
            employee.validation_status = 'APPROVED'
        else:
            employee.validation_status = 'INCOMPLETE'
        
        # Determine overall status
        if doc_count == 0 or employee.validation_status == 'INCOMPLETE':
            employee.overall_status = 'INCOMPLETE'
        elif pending_updates or documents.filter(status='PENDING').exists():
            employee.overall_status = 'PENDING'
        elif doc_count >= 3 and employee.validation_status == 'APPROVED' and not documents.filter(status='REJECTED').exists():
            employee.overall_status = 'APPROVED'
        else:
            employee.overall_status = 'PENDING'
    
    # Filter employees based on status
    if status_filter != 'all':
        employees = [emp for emp in employees if emp.overall_status == status_filter]
    
    # Pagination
    paginator = Paginator(employees, 10)
    page = request.GET.get('page')
    employees = paginator.get_page(page)
    
    context = {
        'employees': employees,
        'status_filter': status_filter,
        'is_hr_admin': True,
    }
    return render(request, "employee/document_verification.html", context)

@login_required(login_url='/')
@role_required(['ADMIN', 'HR'])
def verify_document(request, doc_id):
    document = get_object_or_404(Document, id=doc_id)
    if request.method == "POST":
        status = request.POST.get('status')
        comments = request.POST.get('comments', '')
        document.status = status
        document.verified_by = request.user
        document.verified_at = timezone.now()
        document.comments = comments
        document.save()
        AuditLog.objects.create(
            user=request.user,
            action=f"Document Verification - {status}",
            details=f"Document {doc_id} verified for {document.employee.eID}"
        )
        messages.success(request, "Document verification updated successfully!")
        return redirect('document_verification')
    return render(request, "employee/verify_document.html", {
        'document': document
    })

@login_required
@role_required(['ADMIN', 'HR'])
def admin_dashboard(request):
    if not request.user.is_staff:
        return redirect('dashboard')
        
    employees = Employee.objects.all()
    user_profiles = UserProfile.objects.all()
    
    # Get asset data
    assets = Asset.objects.all()
    total_assets = assets.count()
    available_assets = assets.filter(status='Available').count()
    assigned_assets = assets.filter(status='Assigned').count()
    maintenance_assets = assets.filter(status='Under Maintenance').count()
    
    # Prepare data for each tab using UserProfile
    bank_details = []
    insurance_policies = []
    tax_details = []
    personal_details = []
    
    for emp in employees:
        try:
            profile = UserProfile.objects.get(user__username=emp.eID)
            bank_details.append({
                'employee': emp,
                'account_number': profile.bank_account_number if hasattr(profile, 'bank_account_number') else '',
                'ifsc': profile.bank_ifsc if hasattr(profile, 'bank_ifsc') else ''
            })
            personal_details.append({
                'employee': emp,
                'emergency_contact_name': profile.emergency_contact_name if hasattr(profile, 'emergency_contact_name') else '',
                'emergency_contact_phone': profile.emergency_contact_phone if hasattr(profile, 'emergency_contact_phone') else ''
            })
        except UserProfile.DoesNotExist:
            bank_details.append({'employee': emp, 'account_number': '', 'ifsc': ''})
            personal_details.append({'employee': emp, 'emergency_contact_name': '', 'emergency_contact_phone': ''})
        
        # Stub data for insurance and tax
        insurance_policies.append({'employee': emp, 'policy': 'N/A'})
        tax_details.append({'employee': emp, 'tax': 'N/A'})
    
    context = {
        'employees': employees,
        'bank_details': bank_details,
        'insurance_policies': insurance_policies,
        'tax_details': tax_details,
        'personal_details': personal_details,
        # Asset data
        'assets': assets,
        'total_assets': total_assets,
        'available_assets': available_assets,
        'assigned_assets': assigned_assets,
        'maintenance_assets': maintenance_assets,
    }
    return render(request, 'employee/admin_dashboard.html', context)

@login_required
@role_required(['HR', 'Admin'])
def export_employees(request):
    """Export employee data to CSV"""
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="employees.csv"'
    
    writer = csv.writer(response)
    writer.writerow(['ID', 'Name', 'Email', 'Department', 'Position', 'Join Date', 'Status'])
    
    employees = Employee.objects.all()
    for employee in employees:
        writer.writerow([
            employee.id,
            employee.user.get_full_name(),
            employee.user.email,
            employee.department,
            employee.position,
            employee.join_date,
            'Active' if employee.user.is_active else 'Inactive'
        ])
    
    return response

@login_required
@role_required(['HR', 'Admin'])
def generate_payroll(request):
    """Generate payroll for all employees"""
    if request.method == 'POST':
        month = request.POST.get('month')
        year = request.POST.get('year')
        
        # Generate payroll for each employee
        employees = Employee.objects.all()
        for employee in employees:
            # Calculate basic salary
            basic_salary = employee.salary
            
            # Calculate allowances
            allowances = 0
            if hasattr(employee, 'allowances'):
                allowances = sum(allowance.amount for allowance in employee.allowances.all())
            
            # Calculate deductions
            deductions = 0
            if hasattr(employee, 'deductions'):
                deductions = sum(deduction.amount for deduction in employee.deductions.all())
            
            # Calculate net salary
            net_salary = basic_salary + allowances - deductions
            
            # Create payroll record
            Payroll.objects.create(
                employee=employee,
                month=month,
                year=year,
                basic_salary=basic_salary,
                allowances=allowances,
                deductions=deductions,
                net_salary=net_salary,
                status='Pending'
            )
        
        messages.success(request, 'Payroll generated successfully!')
        return redirect('admin_dashboard')
    
    return render(request, 'employee/generate_payroll.html', {
        'page_title': 'Generate Payroll',
        'active_page': 'payroll'
    })

@login_required
@role_required(['ADMIN', 'HR'])
def manage_job_openings(request):
    """View for managing job openings."""
    job_openings = JobOpening.objects.all().order_by('-created_at')
    
    if request.method == "POST":
        action = request.POST.get('action')
        if action == 'add':
            title = request.POST.get('title')
            department = request.POST.get('department')
            description = request.POST.get('description')
            requirements = request.POST.get('requirements')
            positions = request.POST.get('positions', 1)
            
            JobOpening.objects.create(
                title=title,
                department=department,
                description=description,
                requirements=requirements,
                positions=positions,
                created_by=request.user
            )
            messages.success(request, "Job opening created successfully!")
            
        elif action == 'update':
            job_id = request.POST.get('job_id')
            job = get_object_or_404(JobOpening, id=job_id)
            job.status = request.POST.get('status')
            job.save()
            messages.success(request, "Job opening updated successfully!")
            
        elif action == 'delete':
            job_id = request.POST.get('job_id')
            job = get_object_or_404(JobOpening, id=job_id)
            job.delete()
            messages.success(request, "Job opening deleted successfully!")
            
    context = {
        'page_title': 'Manage Job Openings',
        'active_page': 'jobs',
        'job_openings': job_openings,
        'departments': designations_opt
    }
    return render(request, 'employee/manage_jobs.html', context)

@login_required(login_url='/ems/accounts/login/')
def employee_onboarding(request):
    if request.method == 'POST' and request.user.is_staff:
        try:
            import uuid
            from datetime import datetime
            
            # Auto-generate Employee ID
            def generate_employee_id():
                return 'EMP' + uuid.uuid4().hex[:8].upper()
            employee_id = generate_employee_id()

            # Get form data
            first_name = request.POST['firstName']
            middle_name = request.POST.get('middleName', '')
            last_name = request.POST['lastName']
            email = request.POST['email']
            join_date_str = request.POST['joinDate']
            designation = request.POST['designation']

            # Convert join_date string to datetime object
            try:
                # First try the HTML5 date format (YYYY-MM-DD)
                join_date = datetime.strptime(join_date_str, '%Y-%m-%d').date()
            except ValueError:
                try:
                    # Then try the display format (DD-MM-YYYY)
                    join_date = datetime.strptime(join_date_str, '%d-%m-%Y').date()
                except ValueError:
                    messages.error(request, 'Invalid date format. Please use YYYY-MM-DD format.')
                    return redirect('employee_onboarding')

            # Generate a temporary Aadhar number that's unique
            temp_aadhar = f'TEMP_{employee_id}'

            # Create new employee with minimal required fields
            employee = Employee.objects.create(
                eID=employee_id,
                firstName=first_name,
                middleName=middle_name,
                lastName=last_name,
                email=email,
                joinDate=join_date,
                designation=designation,
                phoneNo=None,
                dOB=timezone.now().date(),
                salary='0',
                addharNo=temp_aadhar  # Using the unique temporary Aadhar number
            )

            # Create User account for the employee
            try:
                # Generate a random password
                temp_password = ''.join(random.choices(string.ascii_letters + string.digits, k=12))
                user = User.objects.create_user(
                    username=employee_id,
                    email=email,
                    password=temp_password,
                    first_name=first_name,
                    last_name=last_name
                )
                UserProfile.objects.create(
                    user=user,
                    role='EMPLOYEE',
                    profile_completion=0
                )

                # Send notification email using Microsoft Graph API
                try:
                    from .utils import send_new_employee_notification
                    send_new_employee_notification(employee, temp_password)
                    messages.success(request, f'Employee created successfully with ID: {employee_id}. Welcome email with login credentials sent.')
                except Exception as email_error:
                    print(f"Email sending failed: {str(email_error)}")
                    messages.warning(request, f'''Employee created successfully with ID: {employee_id}.
                    However, welcome email could not be sent. Please provide these credentials manually:
                    Username: {employee_id}
                    Temporary Password: {temp_password}''')

            except Exception as user_error:
                employee.delete()  # Rollback employee creation if user creation fails
                raise Exception(f"Failed to create user account: {str(user_error)}")

            return redirect('employee_onboarding')
        except Exception as e:
            print(f"Employee creation failed with error: {str(e)}")
            messages.error(request, f'Error creating employee: {str(e)}')
    employees = Employee.objects.all().order_by('-joinDate')
    return render(request, 'employee/onboarding.html', {
        'employees': employees,
        'designations_opt': designations_opt
    })

@login_required
def complete_onboarding(request, employee_id):
    if not request.user.is_staff:
        messages.error(request, 'You do not have permission to perform this action.')
        return redirect('dashboard')
    
    try:
        employee = Employee.objects.get(eID=employee_id)
        employee.onboarding_completed = True
        employee.onboarding_date = timezone.now()
        employee.save()
        
        # Send completion email
        send_mail(
            'Onboarding Completed',
            f'''Dear {employee.firstName},

Your onboarding process has been completed successfully.

You can now access all company resources using your company email: {employee.email}

Best regards,
HR Team''',
            settings.DEFAULT_FROM_EMAIL,
            [employee.personal_email],
            fail_silently=False,
        )
        
        messages.success(request, 'Onboarding completed successfully.')
    except Employee.DoesNotExist:
        messages.error(request, 'Employee not found.')
    except Exception as e:
        messages.error(request, f'Error completing onboarding: {str(e)}')
    
    return redirect('employee_onboarding')

@login_required
def update_profile(request):
    if request.method == "POST":
        user_profile = get_object_or_404(UserProfile, user=request.user)
        employee = get_object_or_404(Employee, eID=request.user.username)
        
        # Update employee info
        if 'phone' in request.POST:
            employee.phoneNo = request.POST.get('phone')
        if 'email' in request.POST:
            employee.email = request.POST.get('email')
            
        # Update profile info
        if 'emergency_contact_name' in request.POST:
            user_profile.emergency_contact_name = request.POST.get('emergency_contact_name')
        if 'emergency_contact_phone' in request.POST:
            user_profile.emergency_contact_phone = request.POST.get('emergency_contact_phone')
        if 'bank_account' in request.POST:
            user_profile.bank_account_number = request.POST.get('bank_account')
        if 'ifsc' in request.POST:
            user_profile.bank_ifsc = request.POST.get('ifsc')
        
        employee.save()
        
        # Calculate profile completion
        fields = [
            employee.phoneNo, employee.email,
            user_profile.emergency_contact_name,
            user_profile.emergency_contact_phone,
            user_profile.bank_account_number,
            user_profile.bank_ifsc
        ]
        completed = sum(1 for field in fields if field)
        user_profile.profile_completion = (completed / len(fields)) * 100
        user_profile.save()
        
        messages.success(request, "Profile updated successfully!")
        
    return redirect('employee_onboarding')

@login_required
def performance_review_list(request):
    try:
        user_profile = UserProfile.objects.get(user=request.user)
        if user_profile.role in ['ADMIN', 'HR']:
            reviews = PerformanceReview.objects.all()
        else:
            employee = Employee.objects.get(eID=request.user.username)
            reviews = PerformanceReview.objects.filter(employee=employee)
        return render(request, 'employee/performance_review_list.html', {'reviews': reviews})
    except (UserProfile.DoesNotExist, Employee.DoesNotExist):
        reviews = []
        return render(request, 'employee/performance_review_list.html', {'reviews': reviews})

@login_required
def create_performance_review(request):
    if not request.user.is_staff:
        messages.error(request, "Only staff members can create performance reviews.")
        return redirect('performance_review_list')
        
    if request.method == 'POST':
        employee_id = request.POST.get('employee')
        rating = request.POST.get('rating')
        comments = request.POST.get('comments')
        goals_achieved = request.POST.get('goals_achieved')
        areas_of_improvement = request.POST.get('areas_of_improvement')
        next_review_date = request.POST.get('next_review_date')

        try:
            employee = Employee.objects.get(eID=employee_id)
            review = PerformanceReview.objects.create(
                employee=employee,
                reviewer=request.user,
                review_date=timezone.now().date(),
                rating=rating,
                comments=comments,
                goals_achieved=goals_achieved,
                areas_of_improvement=areas_of_improvement,
                next_review_date=next_review_date
            )
            messages.success(request, 'Performance review created successfully.')
            return redirect('performance_review_list')
        except Employee.DoesNotExist:
            messages.error(request, 'Selected employee does not exist.')
            
    employees = Employee.objects.all()
    return render(request, 'employee/create_performance_review.html', {'employees': employees})

@login_required
def goal_list(request):
    try:
        user_profile = UserProfile.objects.get(user=request.user)
        if user_profile.role in ['ADMIN', 'HR']:
            goals = Goal.objects.all()
        else:
            employee = Employee.objects.get(eID=request.user.username)
            goals = Goal.objects.filter(employee=employee)
        return render(request, 'employee/goal_list.html', {'goals': goals})
    except (UserProfile.DoesNotExist, Employee.DoesNotExist):
        goals = []
        return render(request, 'employee/goal_list.html', {'goals': goals})

@login_required
def create_goal(request):
    try:
        employee = Employee.objects.get(eID=request.user.username)
        if request.method == 'POST':
            title = request.POST.get('title')
            description = request.POST.get('description')
            start_date = request.POST.get('start_date')
            target_date = request.POST.get('target_date')

            goal = Goal.objects.create(
                employee=employee,
                title=title,
                description=description,
                start_date=start_date,
                target_date=target_date,
                status='NOT_STARTED'
            )
            messages.success(request, 'Goal created successfully.')
            return redirect('goal_list')
        return render(request, 'employee/create_goal.html')
    except Employee.DoesNotExist:
        messages.error(request, 'Employee profile not found.')
        return redirect('dashboard')

def get_employee_name(eid):
    try:
        emp = Employee.objects.get(eID=eid)
        return f"{emp.firstName} {emp.lastName}"
    except Employee.DoesNotExist:
        return eid

@login_required
def leave_request_list(request):
    try:
        user_profile = UserProfile.objects.get(user=request.user)
        if request.user.is_staff:
            requests = LeaveRequest.objects.all()
        else:
            requests = LeaveRequest.objects.filter(eId=request.user.username)
        # Attach employee name for template
        for req in requests:
            req.employee_name = get_employee_name(req.eId)
        return render(request, 'employee/leave_request_list.html', {'requests': requests})
    except UserProfile.DoesNotExist:
        requests = []
        return render(request, 'employee/leave_request_list.html', {'requests': requests})

@login_required
def create_leave_request(request):
    if request.method == 'POST':
        leave_type = request.POST.get('leave_type')
        start_date = request.POST.get('start_date')
        end_date = request.POST.get('end_date')
        reason = request.POST.get('reason')
        # Validation: start_date <= end_date
        if start_date > end_date:
            messages.error(request, 'End date cannot be before start date.')
            return redirect('create_leave_request')
        # Validation: no overlapping leave
        overlap = LeaveRequest.objects.filter(
            eId=request.user.username,
            status__in=['PENDING', 'APPROVED'],
            start_date__lte=end_date,
            end_date__gte=start_date
        ).exists()
        if overlap:
            messages.error(request, 'You already have a leave request for these dates.')
            return redirect('create_leave_request')
        request_obj = LeaveRequest.objects.create(
            eId=request.user.username,
            leave_type=leave_type,
            start_date=start_date,
            end_date=end_date,
            reason=reason,
            status='PENDING'
        )
        AuditLog.objects.create(user=request.user, action='Leave Request', details=f'Requested {leave_type} leave from {start_date} to {end_date}')
        messages.success(request, 'Leave request submitted successfully.')
        return redirect('leave_request_list')
    return render(request, 'employee/create_leave_request.html')

@login_required
def approve_leave_request(request, request_id):
    try:
        user_profile = UserProfile.objects.get(user=request.user)
        if not request.user.is_staff:
            messages.error(request, 'Only staff members can approve/reject leave requests.')
            return redirect('leave_request_list')
        leave_request = get_object_or_404(LeaveRequest, id=request_id)
        action = request.GET.get('action', 'approve')
        if action == 'reject':
            leave_request.status = 'REJECTED'
            messages.success(request, 'Leave request rejected.')
            AuditLog.objects.create(user=request.user, action='Leave Rejected', details=f'Rejected leave for {leave_request.eId} ({leave_request.start_date} to {leave_request.end_date})')
        else:
            leave_request.status = 'APPROVED'
            messages.success(request, 'Leave request approved.')
            AuditLog.objects.create(user=request.user, action='Leave Approved', details=f'Approved leave for {leave_request.eId} ({leave_request.start_date} to {leave_request.end_date})')
        leave_request.approved_by = request.user
        leave_request.save()
    except UserProfile.DoesNotExist:
        messages.error(request, 'User profile not found.')
    return redirect('leave_request_list')

@login_required
def clock_in(request):
    """Handle employee clock in"""
    if request.method == 'POST':
    try:
            employee = Employee.objects.get(email=request.user.email)
        today = timezone.now().date()
            
            # Check if already clocked in
            if Attendance.objects.filter(eId=employee, date=today).exists():
                messages.error(request, 'You have already clocked in today.')
                return redirect('attendance_list')

        # Create new attendance record
            current_time = timezone.now()
        attendance = Attendance.objects.create(
                eId=employee,
            date=today,
                time_in=current_time,
                status='Present'
            )
            
            messages.success(request, 'Successfully clocked in!')
        except Employee.DoesNotExist:
            messages.error(request, 'Employee profile not found. Please contact HR.')
    except Exception as e:
            messages.error(request, f'Error clocking in: {str(e)}')
            
    return redirect('attendance_list')

@login_required
def clock_out(request):
    """Handle employee clock out"""
    if request.method == 'POST':
    try:
            employee = Employee.objects.get(email=request.user.email)
        today = timezone.now().date()

            # Get today's attendance record
        attendance = Attendance.objects.filter(
                eId=employee,
                date=today
        ).first()

        if not attendance:
                messages.error(request, 'You have not clocked in today.')
                return redirect('attendance_list')
                
            if attendance.time_out:
                messages.error(request, 'You have already clocked out today.')
                return redirect('attendance_list')
            
            # Update attendance record
            current_time = timezone.now()
        attendance.time_out = current_time
            
            # Calculate overtime if any
            if attendance.shift:
                shift_end = timezone.make_aware(
                    datetime.combine(today, attendance.shift.end_time)
                )
                if current_time > shift_end:
                    overtime = current_time - shift_end
                    attendance.overtime_hours = overtime.total_seconds() / 3600
            
            attendance.save()
            messages.success(request, 'Successfully clocked out!')
        except Employee.DoesNotExist:
            messages.error(request, 'Employee profile not found. Please contact HR.')
    except Exception as e:
            messages.error(request, f'Error clocking out: {str(e)}')
            
    return redirect('attendance_list')

@login_required
def attendance_list(request):
    """View for employees to see their attendance records and clock in/out"""
    try:
        # Get employee record using email instead of user
        employee = Employee.objects.get(email=request.user.email)
        
        # Get today's attendance record
        today = timezone.now().date()
        today_attendance = Attendance.objects.filter(
            eId=employee,
            date=today
        ).first()
        
        # Get attendance history for current month
        start_date = today.replace(day=1)
        if today.month == 12:
            end_date = today.replace(year=today.year + 1, month=1, day=1) - timezone.timedelta(days=1)
        else:
            end_date = today.replace(month=today.month + 1, day=1) - timezone.timedelta(days=1)
            
        attendance_records = Attendance.objects.filter(
            eId=employee,
            date__range=[start_date, end_date]
        ).select_related('shift').order_by('-date', '-time_in')
        
        context = {
            'today_attendance': today_attendance,
            'attendance_records': attendance_records,
            'today': today,
            'employee': employee
        }
        return render(request, 'employee/attendance_list.html', context)
    except Employee.DoesNotExist:
        messages.error(request, 'Employee profile not found. Please contact HR.')
        return redirect('admin_dashboard')

@login_required
@staff_member_required
def admin_attendance(request):
    """View for HR to manage attendance"""
    try:
        # Get current month's attendance records
        today = timezone.now().date()
        start_date = today.replace(day=1)
        if today.month == 12:
            end_date = today.replace(year=today.year + 1, month=1, day=1) - timezone.timedelta(days=1)
        else:
            end_date = today.replace(month=today.month + 1, day=1) - timezone.timedelta(days=1)
            
        attendance_records = Attendance.objects.filter(
            date__range=[start_date, end_date]
        ).select_related('shift', 'adjusted_by').order_by('-date', '-time_in')
        
        # Get all employees and shifts for the form
        employees = Employee.objects.all().order_by('firstName', 'lastName')
        shifts = Shift.objects.all().order_by('name')
        
        if request.method == 'POST':
            action = request.POST.get('action')
            
            if action == 'allocate_shift':
                employee_id = request.POST.get('employee')
                shift_id = request.POST.get('shift')
                start_date = request.POST.get('start_date')
                
                try:
                    employee = Employee.objects.get(id=employee_id)
                    shift = Shift.objects.get(id=shift_id)
                    
                    # Create attendance record for the employee
                    attendance = Attendance.objects.create(
                        eId=employee,
                        date=start_date,
                        shift=shift,
                        status='Present'
                    )
                    
                    messages.success(request, f'Shift allocated to {employee.firstName} {employee.lastName}')
                except (Employee.DoesNotExist, Shift.DoesNotExist):
                    messages.error(request, 'Invalid employee or shift selected')
                    
            elif action == 'approve_attendance':
                attendance_id = request.POST.get('attendance_id')
                status = request.POST.get('status')
                
                try:
                    attendance = Attendance.objects.get(id=attendance_id)
                    attendance.status = status
                    attendance.adjusted_by = request.user
                    attendance.save()
                    
                    messages.success(request, 'Attendance status updated successfully')
                except Attendance.DoesNotExist:
                    messages.error(request, 'Attendance record not found')

    context = {
            'attendance_records': attendance_records,
        'employees': employees,
            'shifts': shifts,
            'today': today,
            'start_date': start_date,
            'end_date': end_date
    }
    return render(request, 'employee/admin_attendance.html', context)
    except Exception as e:
        messages.error(request, f'Error: {str(e)}')
        return redirect('admin_dashboard')

@login_required
@user_passes_test(is_hr_or_admin)
def attendance_reports(request):
    # Get date range
    end_date = timezone.now().date()
    start_date = end_date - timedelta(days=30)
    
    # Get attendance statistics
    attendance_stats = Attendance.objects.filter(
        date__range=[start_date, end_date]
    ).aggregate(
        total_present=Count('id', filter=Q(status='PRESENT')),
        total_late=Count('id', filter=Q(is_late=True)),
        total_absent=Count('id', filter=Q(status='ABSENT')),
        total_half_day=Count('id', filter=Q(status='HALF_DAY')),
        avg_overtime=Avg('overtime_hours')
    )
    
    # Get daily attendance trends
    daily_trends = Attendance.objects.filter(
        date__range=[start_date, end_date]
    ).values('date').annotate(
        present=Count('id', filter=Q(status='PRESENT')),
        late=Count('id', filter=Q(is_late=True)),
        absent=Count('id', filter=Q(status='ABSENT'))
    ).order_by('date')
    
    # Get monthly attendance summary
    monthly_summary = Attendance.objects.filter(
        date__range=[start_date, end_date]
    ).annotate(
        month=TruncMonth('date')
    ).values('month').annotate(
        present=Count('id', filter=Q(status='PRESENT')),
        late=Count('id', filter=Q(is_late=True)),
        absent=Count('id', filter=Q(status='ABSENT'))
    ).order_by('month')
    
    # Get employee-wise attendance summary
    employee_attendance = Employee.objects.annotate(
        present=Count('eID', filter=Q(
            attendance__date__range=[start_date, end_date],
            attendance__status='PRESENT'
        )),
        late=Count('eID', filter=Q(
            attendance__date__range=[start_date, end_date],
            attendance__is_late=True
        )),
        absent=Count('eID', filter=Q(
            attendance__date__range=[start_date, end_date],
            attendance__status='ABSENT'
        ))
    ).order_by('-present')
    
    context = {
        'attendance_stats': attendance_stats,
        'daily_trends': list(daily_trends),
        'monthly_summary': list(monthly_summary),
        'employee_attendance': employee_attendance,
        'start_date': start_date,
        'end_date': end_date
    }
    
    return render(request, 'employee/attendance_reports.html', context)

@login_required
@user_passes_test(is_hr_or_admin)
def employee_attendance_detail(request, employee_id):
    # Get date range
    end_date = timezone.now().date()
    start_date = end_date - timedelta(days=30)

    # Get employee
    employee = get_object_or_404(Employee, eID=employee_id)

    # Get attendance records
    attendance_records = Attendance.objects.filter(
        eId=employee_id,
        date__range=[start_date, end_date]
    ).order_by('-date')

    # Calculate attendance statistics
    attendance_stats = {
        'present': attendance_records.filter(status='PRESENT').count(),
        'late': attendance_records.filter(is_late=True).count(),
        'absent': attendance_records.filter(status='ABSENT').count(),
        'total_overtime': attendance_records.aggregate(
            total=Sum('overtime_hours')
        )['total'] or 0
    }

    # Prepare data for charts
    attendance_data = attendance_records.annotate(
        work_hours=models.F('overtime_hours') + 8  # Assuming 8 hours work day
    ).values('date', 'work_hours', 'overtime_hours')
    
    context = {
        'employee': employee,
        'attendance_records': attendance_records,
        'attendance_stats': attendance_stats,
        'attendance_data': json.dumps(list(attendance_data), default=str),
        'start_date': start_date,
        'end_date': end_date
    }

    return render(request, 'employee/employee_attendance_detail.html', context)

@login_required
@role_required(['ADMIN', 'HR'])
def export_attendance(request):
    # Get filter parameters
    date_from = request.GET.get('date_from')
    date_to = request.GET.get('date_to')
    employee_id = request.GET.get('employee_id')
    status = request.GET.get('status')
    
    # Get attendance records
    attendance_records = Attendance.objects.all()
    
    # Apply filters
    if date_from:
        attendance_records = attendance_records.filter(date__gte=date_from)
    if date_to:
        attendance_records = attendance_records.filter(date__lte=date_to)
    if employee_id:
        attendance_records = attendance_records.filter(eId=employee_id)
    if status:
        attendance_records = attendance_records.filter(status=status)
    
    # Order records
    attendance_records = attendance_records.order_by('date', 'eId')
    
    # Create CSV response
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="attendance_report.csv"'
    
    writer = csv.writer(response)
    writer.writerow(['Date', 'Employee ID', 'Time In', 'Time Out', 'Status', 'Overtime Hours', 'Location', 'Is Remote', 'Notes'])
    
    for record in attendance_records:
        writer.writerow([
            record.date,
            record.eId,
            record.time_in,
            record.time_out,
            record.status,
            record.overtime_hours,
            record.location,
            record.is_remote,
            record.notes
        ])
    
    return response

@login_required
@user_passes_test(lambda u: u.userprofile.role in ['ADMIN', 'HR'])
def admin_leave_management(request):
    # Get leave statistics
    today = timezone.now().date()
    pending_count = Leave.objects.filter(status='pending').count()
    approved_today = Leave.objects.filter(status='approved', approved_at__date=today).count()
    rejected_today = Leave.objects.filter(status='rejected', updated_at__date=today).count()
    active_leaves = Leave.objects.filter(
        status='approved',
        start_date__lte=today,
        end_date__gte=today
    ).count()

    # Get all leave requests
    leaves = Leave.objects.all().order_by('-created_at')

    context = {
        'pending_count': pending_count,
        'approved_today': approved_today,
        'rejected_today': rejected_today,
        'active_leaves': active_leaves,
        'leaves': leaves,
    }
    return render(request, 'employee/admin_leave_management.html', context)

@login_required
@user_passes_test(lambda u: u.userprofile.role in ['ADMIN', 'HR'])
def leave_details(request, leave_id):
    try:
        leave = Leave.objects.get(id=leave_id)
        data = {
            'employee_name': f"{leave.employee.firstName} {leave.employee.lastName}",
            'leave_type': leave.leave_type.name,
            'start_date': leave.start_date.strftime('%Y-%m-%d'),
            'end_date': leave.end_date.strftime('%Y-%m-%d'),
            'duration': leave.duration,
            'reason': leave.reason,
            'status': leave.get_status_display(),
            'approved_by': leave.approved_by.get_full_name() if leave.approved_by else None,
            'rejection_reason': leave.rejection_reason,
        }
        return JsonResponse(data)
    except Leave.DoesNotExist:
        return JsonResponse({'error': 'Leave request not found'}, status=404)

@login_required
@user_passes_test(lambda u: u.userprofile.role in ['ADMIN', 'HR'])
def process_leave_request(request):
    if request.method != 'POST':
        return redirect('admin_leave_management')
    
    leave_id = request.POST.get('leave_id')
    action = request.POST.get('action')
    rejection_reason = request.POST.get('rejection_reason', '')
    
    try:
        leave = Leave.objects.get(id=leave_id)
        
        if action == 'approve':
            leave.status = 'approved'
            leave.approved_by = request.user
            leave.approved_at = timezone.now()
            messages.success(request, 'Leave request approved successfully.')
        elif action == 'reject':
            if not rejection_reason:
                messages.error(request, 'Please provide a reason for rejection.')
                return redirect('leave_details', leave_id=leave_id)
            leave.status = 'rejected'
            leave.rejection_reason = rejection_reason
            messages.success(request, 'Leave request rejected successfully.')
        else:
            messages.error(request, 'Invalid action.')
            return redirect('leave_details', leave_id=leave_id)
        
        leave.save()
        AuditLog.objects.create(
            user=request.user,
            action=f'Leave {action.title()}',
            details=f'{action.title()}ed leave request for {leave.employee.firstName} {leave.employee.lastName}'
        )
        return redirect('admin_leave_management')
        
    except Leave.DoesNotExist:
        messages.error(request, 'Leave request not found.')
        return redirect('admin_leave_management')
    except Exception as e:
        messages.error(request, f'An error occurred: {str(e)}')
        return redirect('admin_leave_management')

@login_required
def leave_balance(request):
    try:
        employee = Employee.objects.get(eID=request.user.username)
        current_year = timezone.now().year
        
        # Get all leave types
        leave_types = LeaveType.objects.filter(is_active=True)
        
        # Get or create balances for each leave type
        balances = []
        for leave_type in leave_types:
            balance, created = LeaveBalance.objects.get_or_create(
                employee=employee,
                leave_type=leave_type,
                year=current_year,
                defaults={
                    'total_days': leave_type.max_days
                }
            )
            
            # Get approved leaves for this type
            approved_leaves = Leave.objects.filter(
                employee=employee,
                leave_type=leave_type,
                status='approved',
                start_date__year=current_year
            )
            
            # Get pending leaves for this type
            pending_leaves = Leave.objects.filter(
                employee=employee,
                leave_type=leave_type,
                status='pending',
                start_date__year=current_year
            )
            
            balances.append({
                'leave_type': leave_type,
                'total_days': balance.total_days,
                'used_days': balance.used_days,
                'carried_forward': balance.carried_forward,
                'balance': balance.balance,
                'pending_days': sum(leave.duration for leave in pending_leaves)
            })
        
        context = {
            'employee': employee,
            'balances': balances,
            'year': current_year
        }
        
        return render(request, 'employee/leave_balance.html', context)
        
    except Employee.DoesNotExist:
        messages.error(request, "Employee record not found.")
        return redirect('dashboard')

